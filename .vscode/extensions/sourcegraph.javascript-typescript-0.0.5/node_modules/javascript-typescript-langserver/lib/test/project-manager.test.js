"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai = require("chai");
const chaiAsPromised = require("chai-as-promised");
const fs_1 = require("../fs");
const memfs_1 = require("../memfs");
const project_manager_1 = require("../project-manager");
const fs_helpers_1 = require("./fs-helpers");
chai.use(chaiAsPromised);
const assert = chai.assert;
describe('ProjectManager', () => {
    let projectManager;
    let memfs;
    it('should add a ProjectConfiguration when a tsconfig.json is added to the InMemoryFileSystem', () => {
        memfs = new memfs_1.InMemoryFileSystem('/');
        const localfs = new fs_helpers_1.MapFileSystem(new Map([
            ['file:///foo/tsconfig.json', '{}']
        ]));
        const updater = new fs_1.FileSystemUpdater(localfs, memfs);
        projectManager = new project_manager_1.ProjectManager('/', memfs, updater, true);
        memfs.add('file:///foo/tsconfig.json', '{}');
        const configs = Array.from(projectManager.configurations());
        assert.isDefined(configs.find(config => config.configFilePath === '/foo/tsconfig.json'));
    });
    describe('ensureBasicFiles', () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            memfs = new memfs_1.InMemoryFileSystem('/');
            const localfs = new fs_helpers_1.MapFileSystem(new Map([
                ['file:///project/package.json', '{"name": "package-name-1"}'],
                ['file:///project/tsconfig.json', '{ "compilerOptions": { "typeRoots": ["../types"]} }'],
                ['file:///project/file.ts', 'console.log(GLOBALCONSTANT);'],
                ['file:///types/types.d.ts', 'declare var GLOBALCONSTANT=1;']
            ]));
            const updater = new fs_1.FileSystemUpdater(localfs, memfs);
            projectManager = new project_manager_1.ProjectManager('/', memfs, updater, true);
        }));
        it('loads files from typeRoots', () => __awaiter(this, void 0, void 0, function* () {
            yield projectManager.ensureReferencedFiles('file:///project/file.ts').toPromise();
            memfs.getContent('file:///project/file.ts');
            memfs.getContent('file:///types/types.d.ts');
        }));
    });
    describe('getPackageName()', () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            memfs = new memfs_1.InMemoryFileSystem('/');
            const localfs = new fs_helpers_1.MapFileSystem(new Map([
                ['file:///package.json', '{"name": "package-name-1"}'],
                ['file:///subdirectory-with-tsconfig/package.json', '{"name": "package-name-2"}'],
                ['file:///subdirectory-with-tsconfig/src/tsconfig.json', '{}'],
                ['file:///subdirectory-with-tsconfig/src/dummy.ts', '']
            ]));
            const updater = new fs_1.FileSystemUpdater(localfs, memfs);
            projectManager = new project_manager_1.ProjectManager('/', memfs, updater, true);
            yield projectManager.ensureAllFiles().toPromise();
        }));
    });
    describe('ensureReferencedFiles()', () => {
        beforeEach(() => {
            memfs = new memfs_1.InMemoryFileSystem('/');
            const localfs = new fs_helpers_1.MapFileSystem(new Map([
                ['file:///package.json', '{"name": "package-name-1"}'],
                ['file:///node_modules/somelib/index.js', '/// <reference path="./pathref.d.ts"/>\n/// <reference types="node"/>'],
                ['file:///node_modules/somelib/pathref.d.ts', ''],
                ['file:///node_modules/%40types/node/index.d.ts', ''],
                ['file:///src/dummy.ts', 'import * as somelib from "somelib";']
            ]));
            const updater = new fs_1.FileSystemUpdater(localfs, memfs);
            projectManager = new project_manager_1.ProjectManager('/', memfs, updater, true);
        });
        it('should ensure content for imports and references is fetched', () => __awaiter(this, void 0, void 0, function* () {
            yield projectManager.ensureReferencedFiles('file:///src/dummy.ts').toPromise();
            memfs.getContent('file:///node_modules/somelib/index.js');
            memfs.getContent('file:///node_modules/somelib/pathref.d.ts');
            memfs.getContent('file:///node_modules/%40types/node/index.d.ts');
        }));
    });
    describe('getConfiguration()', () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            memfs = new memfs_1.InMemoryFileSystem('/');
            const localfs = new fs_helpers_1.MapFileSystem(new Map([
                ['file:///tsconfig.json', '{}'],
                ['file:///src/jsconfig.json', '{}']
            ]));
            const updater = new fs_1.FileSystemUpdater(localfs, memfs);
            projectManager = new project_manager_1.ProjectManager('/', memfs, updater, true);
            yield projectManager.ensureAllFiles().toPromise();
        }));
        it('should resolve best configuration based on file name', () => {
            const jsConfig = projectManager.getConfiguration('/src/foo.js');
            const tsConfig = projectManager.getConfiguration('/src/foo.ts');
            assert.equal('/tsconfig.json', tsConfig.configFilePath);
            assert.equal('/src/jsconfig.json', jsConfig.configFilePath);
        });
    });
    describe('getParentConfiguration()', () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            memfs = new memfs_1.InMemoryFileSystem('/');
            const localfs = new fs_helpers_1.MapFileSystem(new Map([
                ['file:///tsconfig.json', '{}'],
                ['file:///src/jsconfig.json', '{}']
            ]));
            const updater = new fs_1.FileSystemUpdater(localfs, memfs);
            projectManager = new project_manager_1.ProjectManager('/', memfs, updater, true);
            yield projectManager.ensureAllFiles().toPromise();
        }));
        it('should resolve best configuration based on file name', () => {
            const config = projectManager.getParentConfiguration('file:///src/foo.ts');
            assert.isDefined(config);
            assert.equal('/tsconfig.json', config.configFilePath);
        });
    });
    describe('getChildConfigurations()', () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            memfs = new memfs_1.InMemoryFileSystem('/');
            const localfs = new fs_helpers_1.MapFileSystem(new Map([
                ['file:///tsconfig.json', '{}'],
                ['file:///foo/bar/tsconfig.json', '{}'],
                ['file:///foo/baz/tsconfig.json', '{}']
            ]));
            const updater = new fs_1.FileSystemUpdater(localfs, memfs);
            projectManager = new project_manager_1.ProjectManager('/', memfs, updater, true);
            yield projectManager.ensureAllFiles().toPromise();
        }));
        it('should resolve best configuration based on file name', () => {
            const configs = Array.from(projectManager.getChildConfigurations('file:///foo')).map(config => config.configFilePath);
            assert.deepEqual(configs, [
                '/foo/bar/tsconfig.json',
                '/foo/baz/tsconfig.json'
            ]);
        });
    });
});
//# sourceMappingURL=project-manager.test.js.map